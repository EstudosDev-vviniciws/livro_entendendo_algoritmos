üß≠ O que √© o Algoritmo de Dijkstra?
O algoritmo de Dijkstra encontra o caminho de menor custo entre dois n√≥s
em um grafo ponderado (com pesos).Diferente do BFS, que s√≥ serve para grafos
n√£o ponderados, Dijkstra leva em conta os custos dos caminhos.


üìå Terminologia Importante: 
- Grafo ponderado: cada aresta tem um valor/custo.
- Custo: o valor total para chegar a um determinado n√≥.
- Pais (ou predecessores): quem nos levou at√© esse n√≥ (usado para reconstruir o caminho).
- N√≥ processado: j√° verificamos todos os vizinhos dele com os menores custos poss√≠veis.


üõ† Etapas do Algoritmo de Dijkstra:
1. Encontre o n√≥ de menor custo ainda n√£o processado.
2. Para cada vizinho desse n√≥:
- Calcule o custo total para chegar at√© ele.
- Se for menor que o custo atual registrado, atualize.
3. Marque o n√≥ como processado.
4. Repita at√© que todos os n√≥s tenham sido processados.


üéπ Adquirindo um Piano ‚Äì Um Exemplo Pr√°tico
Esse exemplo serve para mostrar a aplica√ß√£o real de Dijkstra: encontrar o
caminho de menor custo entre dois pontos, onde os caminhos possuem diferentes
custos (tempo, dinheiro, etc.).

üß© Situa√ß√£o:
- Voc√™ quer comprar um piano e lev√°-lo at√© sua casa.
- Voc√™ pode ir por v√°rias rotas, mas cada uma tem um custo diferente.
- O objetivo √© minimizar o custo total da entrega.

üó∫Ô∏è Representa√ß√£o:
- Cada cidade √© um n√≥ e cada rota com seu custo √© uma aresta com peso.
- Dijkstra √© usado para encontrar a rota mais barata entre o local do piano e sua casa


‚ö†Ô∏è Arestas com Pesos Negativos:
O algoritmo de Dijkstra n√£o funciona com pesos negativos.

Por qu√™?
Dijkstra assume que, uma vez que voc√™ encontrou o menor custo
para um n√≥, n√£o h√° como melhorar esse custo.
Com pesos negativos, isso pode n√£o ser verdade.

Exemplo:
Se depois de visitar um n√≥, aparece um novo caminho com custo menor 
(por causa de um peso negativo), Dijkstra n√£o reconsidera isso.

Solu√ß√£o?
Para grafos com pesos negativos, use o algoritmo de Bellman-Ford
(visto em cap√≠tulos mais avan√ßados).


üß™ Implementa√ß√£o Comentada (com Dicion√°rios):

'''
Objetivo: Encontrar o caminho de menor custo do ponto
"in√≠cio" at√© o ponto "fim" em um grafo ponderado.
'''

grafo = {
    'inicio': {'a': 5, 'b': 2},
    'a': {'c': 4, 'd': 2},
    'b': {'a': 8, 'd': 7},
    'c': {'fim': 3, 'd': 6},
    'd': {'fim': 1},
    'fim': {}
}

infinito = float('inf')
custos = {'a': 5, 'b': 2, 'c': infinito, 'd': infinito, 'fim': infinito}
pais = {'a': 'inicio', 'b': 'inicio', 'c': None, 'd': None, 'fim': None}
processados = []

def ache_menor_custo(custos):
    menor_custo = float('inf')
    menor_no = None
    for no in custos:
        if custos[no] < menor_custo and no not in processados:
            menor_custo = custos[no]
            menor_no = no
    return menor_no

no = ache_menor_custo(custos)
while no:
    custo = custos[no]
    vizinhos = grafo[no]
    for vizinho in vizinhos:
        novo_custo = custo + vizinhos[vizinho]
        if novo_custo < custos[vizinho]:
            custos[vizinho] = novo_custo
            pais[vizinho] = no
    processados.append(no)
    no = ache_menor_custo(custos)

print("Custos finais:", custos)
print("Pais:", pais)


‚úÖ Conclus√£o:
- O algoritmo de Dijkstra encontra o caminho de menor custo em grafos ponderados.
- √â aplic√°vel em problemas do mundo real, como log√≠stica, rotas e mapas.
- Utiliza tabelas de custos e pais para rastrear os menores caminhos.
- N√£o funciona com pesos negativos (use Bellman-Ford nesse caso).
- Implementado com dicion√°rios e listas.
- Exemplo pr√°tico: encontrar o caminho mais barato para transportar um piano at√© sua casa.

