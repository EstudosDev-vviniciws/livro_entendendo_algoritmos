ğŸ§  O que sÃ£o Algoritmos Gulosos?
SÃ£o algoritmos que fazem a melhor escolha possÃ­vel a cada etapa,
sem se preocupar com o resultado final global.

- Escolhem localmente o que parece melhor.
- Nem sempre fornecem a soluÃ§Ã£o perfeita, mas costumam gerar boas aproximaÃ§Ãµes.
- Muito utilizados em problemas difÃ­ceis de resolver exatamente (ex: NP-completos).


ğŸ« Problema de Cronograma da Sala de Aula:
Objetivo: Agendar o maior nÃºmero possÃ­vel de aulas, sem que seus horÃ¡rios
se sobreponham.
ğŸŸ¢ EstratÃ©gia gulosa: Sempre escolher a aula que termina mais cedo.

ğŸ“Œ Exemplo:

| Aula | InÃ­cio | Fim |
| ---- | ------ | --- |
| A    | 9h     | 10h |
| B    | 9h30   | 11h |
| C    | 10h    | 11h |


ğŸ’ Problema da Mochila (Knapsack):
Objetivo: Colocar os itens com o maior valor total possÃ­vel dentro da mochila,
respeitando o limite de peso.
ğŸŸ¢ EstratÃ©gia gulosa: Ordenar os itens por valor por quilo e pegar os melhores
atÃ© encher a mochila.

ğŸ“Œ Exemplo:

| Item     | Valor | Peso | Valor por kg |
| -------- | ----- | ---- | ------------ |
| Notebook | 3000  | 4kg  | 750          |
| Livro    | 1500  | 3kg  | 500          |
| ViolÃ£o   | 2000  | 2kg  | 1000         |

- Ordem gulosa: ViolÃ£o â†’ Notebook â†’ Livro (atÃ© atingir o peso mÃ¡ximo).


ğŸŒ Problema da Cobertura de Conjuntos (Set Cover):
Objetivo: Escolher o menor nÃºmero possÃ­vel de estaÃ§Ãµes de rÃ¡dio para cobrir
todos os estados.
ğŸŸ¢ EstratÃ©gia gulosa: Sempre escolher a estaÃ§Ã£o que cobre o maior nÃºmero de
estados ainda nÃ£o cobertos.

ğŸ“Œ Exemplo:

estacoes = {
    'kone': {'id', 'nv', 'ut'},
    'ktwo': {'wa', 'id', 'mt'},
    'kthree': {'or', 'nv', 'ca'},
    'kfour': {'nv', 'ut'},
    'kfive': {'ca', 'az'}
}

estados_necessarios = {'mt', 'wa', 'or', 'id', 'nv', 'ut', 'ca', 'az'}

ğŸ“Œ CÃ³digo de soluÃ§Ã£o:

estacoes_finais = set()

while estados_necessarios:
    melhor_estacao = None
    estados_cobertos = set()
    for estacao, estados in estacoes.items():
        cobertos = estados & estados_necessarios
        if len(cobertos) > len(estados_cobertos):
            melhor_estacao = estacao
            estados_cobertos = cobertos
    estados_necessarios -= estados_cobertos
    estacoes_finais.add(melhor_estacao)

print("EstaÃ§Ãµes escolhidas:", estacoes_finais)


ğŸ“ˆ Algoritmos de AproximaÃ§Ã£o:
- SÃ£o algoritmos que nÃ£o garantem a soluÃ§Ã£o perfeita, mas produzem uma
soluÃ§Ã£o suficientemente boa, em tempo viÃ¡vel.
- Ãšteis para problemas NP-completos, onde encontrar a melhor soluÃ§Ã£o pode
ser inviÃ¡vel.


ğŸ“š Conjuntos e Python:
Python oferece suporte nativo a conjuntos com a estrutura set():
- UniÃ£o: A | B
- InterseÃ§Ã£o: A & B
- DiferenÃ§a: A - B


â“ Problemas NP-completos:
SÃ£o problemas muito difÃ­ceis: nÃ£o hÃ¡ algoritmo conhecido que os
resolva rapidamente para todos os casos.

CaracterÃ­sticas:
- Problemas de otimizaÃ§Ã£o (ex: mÃ­nimo de elementos).
- Muitos deles tÃªm milhÃµes de possÃ­veis combinaÃ§Ãµes.
- Resolver um pode ajudar a resolver os outros.


ğŸ” Mesma Rota ou Rota Diferente?
Exemplo de problema NP-completo:
- Dado um conjunto de cidades e distÃ¢ncias entre elas, qual a rota
mais curta que visita todas uma vez e retorna ao ponto inicial?
- Esse Ã© o famoso Problema do Caixeiro Viajante (TSP).

ğŸ§  O nÃºmero de combinaÃ§Ãµes possÃ­veis cresce de forma explosiva com o nÃºmero de cidades.


ğŸ§ª Como saber se um problema Ã© NP-completo?
1. Precisa de verificaÃ§Ã£o rÃ¡pida da soluÃ§Ã£o? (ex: em tempo polinomial)
2. Parece com outro problema NP-completo?
3. A quantidade de combinaÃ§Ãµes cresce exponencialmente?

Se sim, provavelmente Ã© NP-completo.

ğŸ“Œ Exemplos clÃ¡ssicos:
- Problema do caixeiro viajante.
- Cobertura de conjuntos.
- Particionamento de subconjuntos.