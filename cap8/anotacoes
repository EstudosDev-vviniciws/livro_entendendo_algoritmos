üß† O que s√£o Algoritmos Gulosos?
S√£o algoritmos que fazem a melhor escolha poss√≠vel a cada etapa,
sem se preocupar com o resultado final global.

- Escolhem localmente o que parece melhor.
- Nem sempre fornecem a solu√ß√£o perfeita, mas costumam gerar boas aproxima√ß√µes.
- Muito utilizados em problemas dif√≠ceis de resolver exatamente (ex: NP-completos).


üè´ Problema de Cronograma da Sala de Aula:
Objetivo: Agendar o maior n√∫mero poss√≠vel de aulas, sem que seus hor√°rios
se sobreponham.
üü¢ Estrat√©gia gulosa: Sempre escolher a aula que termina mais cedo.

üìå Exemplo:

| Aula | In√≠cio | Fim |
| ---- | ------ | --- |
| A    | 9h     | 10h |
| B    | 9h30   | 11h |
| C    | 10h    | 11h |


üéí Problema da Mochila (Knapsack):
Objetivo: Colocar os itens com o maior valor total poss√≠vel dentro da mochila,
respeitando o limite de peso.
üü¢ Estrat√©gia gulosa: Ordenar os itens por valor por quilo e pegar os melhores
at√© encher a mochila.

üìå Exemplo:

| Item     | Valor | Peso | Valor por kg |
| -------- | ----- | ---- | ------------ |
| Notebook | 3000  | 4kg  | 750          |
| Livro    | 1500  | 3kg  | 500          |
| Viol√£o   | 2000  | 2kg  | 1000         |

- Ordem gulosa: Viol√£o ‚Üí Notebook ‚Üí Livro (at√© atingir o peso m√°ximo).


üåç Problema da Cobertura de Conjuntos (Set Cover):
Objetivo: Escolher o menor n√∫mero poss√≠vel de esta√ß√µes de r√°dio para cobrir
todos os estados.
üü¢ Estrat√©gia gulosa: Sempre escolher a esta√ß√£o que cobre o maior n√∫mero de
estados ainda n√£o cobertos.

üìå Exemplo:

estacoes = {
    'kone': {'id', 'nv', 'ut'},
    'ktwo': {'wa', 'id', 'mt'},
    'kthree': {'or', 'nv', 'ca'},
    'kfour': {'nv', 'ut'},
    'kfive': {'ca', 'az'}
}

estados_necessarios = {'mt', 'wa', 'or', 'id', 'nv', 'ut', 'ca', 'az'}

üìå C√≥digo de solu√ß√£o:

estacoes_finais = set()

while estados_necessarios:
    melhor_estacao = None
    estados_cobertos = set()
    for estacao, estados in estacoes.items():
        cobertos = estados & estados_necessarios
        if len(cobertos) > len(estados_cobertos):
            melhor_estacao = estacao
            estados_cobertos = cobertos
    estados_necessarios -= estados_cobertos
    estacoes_finais.add(melhor_estacao)

print("Esta√ß√µes escolhidas:", estacoes_finais)


üìà Algoritmos de Aproxima√ß√£o:
- S√£o algoritmos que n√£o garantem a solu√ß√£o perfeita, mas produzem uma
solu√ß√£o suficientemente boa, em tempo vi√°vel.
- √öteis para problemas NP-completos, onde encontrar a melhor solu√ß√£o pode
ser invi√°vel.


üìö Conjuntos e Python:
Python oferece suporte nativo a conjuntos com a estrutura set():
- Uni√£o: A | B
- Interse√ß√£o: A & B
- Diferen√ßa: A - B


‚ùì Problemas NP-completos:
S√£o problemas muito dif√≠ceis: n√£o h√° algoritmo conhecido que os
resolva rapidamente para todos os casos.

Caracter√≠sticas:
- Problemas de otimiza√ß√£o (ex: m√≠nimo de elementos).
- Muitos deles t√™m milh√µes de poss√≠veis combina√ß√µes.
- Resolver um pode ajudar a resolver os outros.


üîÅ Mesma Rota ou Rota Diferente?
Exemplo de problema NP-completo:
- Dado um conjunto de cidades e dist√¢ncias entre elas, qual a rota
mais curta que visita todas uma vez e retorna ao ponto inicial?
- Esse √© o famoso Problema do Caixeiro Viajante (TSP).

üß† O n√∫mero de combina√ß√µes poss√≠veis cresce de forma explosiva com o n√∫mero de cidades.


üß™ Como saber se um problema √© NP-completo?
1. Precisa de verifica√ß√£o r√°pida da solu√ß√£o? (ex: em tempo polinomial)
2. Parece com outro problema NP-completo?
3. A quantidade de combina√ß√µes cresce exponencialmente?

Se sim, provavelmente √© NP-completo.

üìå Exemplos cl√°ssicos:
- Problema do caixeiro viajante.
- Cobertura de conjuntos.
- Particionamento de subconjuntos.


‚úÖ Conclus√£o:
- Algoritmos gulosos fazem escolhas locais √≥timas.
- N√£o servem para todos os problemas, mas funcionam bem em muitos.
- S√£o frequentemente usados como algoritmos de aproxima√ß√£o.
- Problemas NP-completos exigem solu√ß√µes pr√°ticas, e os gulosos s√£o uma boa ferramenta.
- Saber modelar o problema corretamente √© fundamental.