üß≠ O que √© um Grafo?
- Um grafo √© uma estrutura de dados que representa rela√ß√µes entre elementos.
- Ele √© composto por n√≥s (v√©rtices) e arestas (liga√ß√µes entre n√≥s).
- Pode ser usado para modelar mapas, redes sociais, rotas, depend√™ncias e muito mais.


üîç O que √© Pesquisa em Largura (BFS)?
- √â um algoritmo que encontra o caminho mais curto (menor n√∫mero de etapas) entre dois pontos em um grafo n√£o ponderado (sem pesos).
- Utiliza uma fila (queue) para explorar os n√≥s por camadas (n√≠veis).
- Ideal para: verificar conex√µes, encontrar o menor n√∫mero de saltos, como "quem est√° mais perto de mim".


üìå Filas (Queues) e Pilhas (Stacks) com deque
O Python fornece a estrutura deque da biblioteca collections, que pode ser usada tanto para filas (FIFO) quanto para pilhas (LIFO).

‚úÖ Fila (FIFO ‚Äì First In, First Out):
- O primeiro elemento a entrar √© o primeiro a sair.
- Usado em algoritmos de busca em largura (BFS).

from collections import deque

fila = deque()
fila.append("Jo√£o")   # entra
fila.append("Maria")  # entra
print(fila.popleft())  # sai: Jo√£o

‚úÖ Pilha (LIFO ‚Äì Last In, First Out):
- O √∫ltimo elemento a entrar √© o primeiro a sair.
- Usado em outros algoritmos como busca em profundidade (DFS).

pilha = deque()
pilha.append("Jo√£o")   # entra
pilha.append("Maria")  # entra
print(pilha.pop())     # sai: Maria

üìå Resumo:
- append() ‚Üí adiciona no final.
- popleft() ‚Üí remove do in√≠cio (FIFO ‚Äì fila).
- pop() ‚Üí remove do final (LIFO ‚Äì pilha).


üõ† Implementando um Grafo em Python: 
- Usamos dicion√°rios para representar os n√≥s e suas conex√µes.

grafo = {
    "voce": ["alice", "bob", "claire"],
    "bob": ["anuj", "peggy"],
    "alice": ["peggy"],
    "claire": ["thom", "jonny"],
    "anuj": [],
    "peggy": [],
    "thom": [],
    "jonny": []
}


üß† Implementando o Algoritmo de BFS:

from collections import deque

def pessoa_e_vendedora(nome):
    return nome[-1] == "m"  # Exemplo: nome termina com "m"

def busca(nome):
    fila = deque()
    fila += grafo[nome]
    verificadas = []

    while fila:
        pessoa = fila.popleft()
        if pessoa not in verificadas:
            if pessoa_e_vendedora(pessoa):
                print(f"{pessoa} √© um vendedor de manga!")
                return True
            else:
                fila += grafo[pessoa]
                verificadas.append(pessoa)
    return False


üìè Encontrando o Caminho M√≠nimo:
- A BFS encontra o menor n√∫mero de conex√µes entre dois pontos.
- Exemplo: encontrar o amigo mais pr√≥ximo que √© vendedor de manga.
- N√£o funciona bem com grafos ponderados (com pesos nos caminhos) ‚Äî para isso usamos Dijkstra (Cap. 7).


‚è± Tempo de Execu√ß√£o

Para grafos com:
- n n√≥s
- e arestas

A complexidade √©: O(n + e)
Isso significa que o tempo de execu√ß√£o depende do n√∫mero total de n√≥s e conex√µes.


‚úÖ Conclus√£o:
- Grafos representam conex√µes entre elementos (n√≥s e arestas).
- A busca em largura (BFS) encontra o caminho mais curto em grafos n√£o ponderados.
- Filas (FIFO) s√£o fundamentais para o funcionamento do algoritmo.
- A estrutura deque facilita a manipula√ß√£o da fila de forma eficiente.
- A implementa√ß√£o em Python √© simples usando dicion√°rios para o grafo e deque para a fila.
- Muito √∫til para problemas como redes sociais, mapas, sistemas de recomenda√ß√£o e buscas em grafos.
